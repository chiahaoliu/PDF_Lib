import os
import time
import yaml
import datetime
import linecache
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from pymatgen import MPRester
from pymatgen.io.cif import CifWriter
from diffpy.Structure import loadStructure
from diffpy.srreal.structureadapter import nosymmetry
from diffpy.srreal.pdfcalculator import DebyePDFCalculator
from diffpy.srreal.pdfcalculator import PDFCalculator

#from pdf_lib.glbl import glbl
from glbl import glbl

class PdfLibBuild(object):
    ''' a class to look up cif data and calculate pdf automatically
    
    Parameters:
    -----------
    API_key : str
        uer-id-like generated from material project
    crystal_system : str
        name of crystal system. Capitalized, like 'CUBIC'
    lib_dir : str
        directory where you wants to store cif and pdf_data
    '''
    def __init__(self, API_key, lib_dir = None):
        # set up API_key
        self.API_key = API_key
        test_m = MPRester(API_key)
        print('You are using %s as API key' % API_key)
        
        # create working dir
        if not lib_dir:
            lib_dir = time.strftime('PDF_Lib_%Y-%m-%d')
        working_dir = os.path.expanduser('~/' + lib_dir)
        self.working_dir = working_dir
        self._makedirs(working_dir) 
        print('Lib dir %s has been built' % working_dir)
        
        # output lib directory
        self.data_dir = None
        self.cif_dir = None  # overwrite it later
        self.output_dir = None # overwrite it later
        self.crystal_system = None # overwrite it later

    def get_symbol_list(self, crystal_system):
        ''' Get short names in one crystal system
        '''
        ref = "Space_group_ref.txt"

        ind_list = []
        ref_path = os.path.join(os.path.dirname(__file__), ref) # relative path
        if os.path.isfile(ref_path):
            print('open {} as reference'.format(ref_path))
            # FIXME - temporily logic. Refine it later with loding Space_group_ref.txt
            with open(ref_path, 'r') as f:
                for ind, line in enumerate(f):
                    if crystal_system in line:
                        ind_list.append(ind-2)
                        # print(ind-2) debug line
            symb_list = []
            for ind in ind_list:
                read = linecache.getline(ref_path, ind)
                position_ind = [ ind for ind, x in enumerate(read) if x== '"']
                #print('position_ind = {}'.format(position_ind)) debug line
                if position_ind:
                    head = min(position_ind)
                    tail = max(position_ind)
                    symb = read[head+1:tail]
                    #print(symb) #degug line
                    symb_list.append(symb)
                else:
                    pass
            return symb_list

    def _makedirs(self, path_name):
        '''function to support python2 stupid logic'''
        if os.path.isdir(path_name):
            pass
        else:
            os.makedirs(path_name)
    
    def cif_lib_build(self, crystal_system, size_limit=None):
        ''' function to build cif and pdf library based on space group symbol
        
        Parameters
        ----------
        crystal_system: str
            name of crystal system. It capitalized, like CUBIC.
            space group symbol will be generated by get_symbol_list method
        size_list : int
            optional. Uppder limit of data pulled out per symbol
        '''
        self.crystal_system = crystal_system
        space_group_symbol = self.get_symbol_list(crystal_system) 
        if isinstance(space_group_symbol, list):
            space_group_symbol_set = space_group_symbol
        else:
            space_group_symbol_set = list(spac_group_symbol)
        ## changing dir
        data_dir = os.path.join(self.working_dir, crystal_system)
        self.data_dir = data_dir
        self._makedirs(data_dir)
        os.chdir(data_dir)
        if os.getcwd() == data_dir:
            print('Library will be built at %s' % data_dir)
        else:
            e = 'Werid, return'
            raise RuntimeError(e)
        
        # summary lists
        missed_list = [] # reference
        m_id_list = [] # reference for searchs have been done in the past
        time_info = time.strftime('%Y-%m-%d')
        # create dirs, cif and calculated dir
        cif_dir = os.path.join(data_dir, 'cif_data')
        self._makedirs(cif_dir)
        self.cif_dir = cif_dir

        # looping
        for space_group_symbol in space_group_symbol_set:
            print('Building library with space_group symbol: {}'.format(space_group_symbol))
            ## search query
            m = MPRester(self.API_key)
            search = m.query(criteria = {"spacegroup.symbol": space_group_symbol},
                            properties = ["material_id"])
            if search:
                ## crazy looping
                if size_limit:
                    dim = 400 # 400 data sets per symbol
                else:
                    dim = len(search)
                print('Pull out %s data sets' % dim)
                print('Now, starts to save cif and compute pdf...')
                
                for i in range(dim):
                    # part 1: grab cif files from data base
                    m_id = search[i]['material_id']
                    m_id_list.append(m_id)
                    m_struc = m.get_structure_by_material_id(m_id)
                    m_formula = m_struc.formula
                    m_name = m_formula.replace(' ', '') # material name
                    
                    cif_w = CifWriter(m_struc)
                    cif_name = '{}_{}.cif'.format(space_group_symbol, m_name)
                    cif_w_name = os.path.join(cif_dir, cif_name)                   
 
                    if os.path.isfile(cif_w_name):
                        print('already have {}, skip'.format(cif_name))
                        pass # skip files already exist
                    else:
                        cif_w.write_file(cif_w_name)
                        print('{} has been saved'.format(cif_name))
            else:
                print('Hmm, no reasult. Something wrong')
                missed_list.append(space_group_symbol)
                pass
        
        m_id_list_name = '{}_{}_material_id.txt'.format(crystal_system, time_info)
        m_id_list_w_name = os.path.join(data_dir, m_id_list_name)
        np.savetxt(m_id_list_w_name, m_id_list)
        print('''SUMMARY: for {} cystsal sytem,
Symbols {} can't be found from data base'''.format(crystal_system, missed_list))
        return cif_dir       
        
    def gr_lib_build(self, cif_lib_path):
        ''' method to calculate G(r) based on path of cif library located at.
    
        Paramters of G(r) calculation are set via glbl.<attribute>, one can tune it based on purpose of building library.
        After entire method, text file contains all G(r), space_group_symbol and material name will be saved respectively

        Parameters
        ----------
        
        cif_lib_path : str
            path to lib of cif files
        
        ''' 
        el_list = []   # data column 
        space_group_symbol_list = [] # reference for search have been done in the past        

        # set up calculation environment
        #dbc = DebyePDFCalculator()
        pdf = PDFCalculator()
        pdf.rstep = glbl.rstep
        cfg = {'qmin': glbl.q_min, 'qmax':glbl.q_max, 'rmin':glbl.r_min, 'rmax': glbl.r_max}
        Bisoequiv = glbl.Bisoequiv #FIXME: current value = 0.5, need to figure out the most suitable value
        print('====Parameter used in this PDF calculator is: {}===='.format(cfg))
        print('====Bisoequiv used in this PDF calculator is: {}===='.format(Bisoequiv))

        # step 1: list cif dir
        output_dir = os.path.join(self.data_dir, 'lib_data')
        self._makedirs(output_dir)
        self.output_dir = output_dir
        cif_f_list = [ f for f in os.listdir(self.cif_dir)]
        
        # hidden step as numpy can't take an empty array and stack
        struc = loadStructure(os.path.join(self.cif_dir, cif_f_list[0]))
        struc.Bisoequiv =  Bisoequiv
        (r,g) = pdf(nosymmetry(struc), **cfg)
        r_grid = np.array(r) # data x-axis
        gr_list = np.empty_like(np.array(g)) # data y-axis        

        for cif in cif_f_list:
            # part 2: calculate PDF with diffpy
            struc = loadStructure(os.path.join(self.cif_dir, cif))
            struc.Bisoequiv =  Bisoequiv
            #(r,g) = pdf(nosymmetry(struc), **cfg)
            (r,g) = pdf(struc, **cfg)
            print('Finished calculation of G(r) on {}'.format(cif))
            sep = cif.index('_')
            space_group_symbol = cif[:sep]
            m_name = cif[sep+1:]
            # part 3: save data
            #if not gr_list.any():
                #gr_list = np.append(gr_list, g)
            gr_list = np.vstack((gr_list,g))
            space_group_symbol_list.append(space_group_symbol)
            el_list.append(m_name)
            #print('size of gr_list = {}'.format(np.shape(gr_list)))
            #space_group_symbol_list = np.concatenate([space_group_symbol_list, space_group_symbol], axis=0)
            #el_list = np.concatenate([el_list, m_name], axis=0)

        time_info = time.strftime('%Y-%m-%d')
        gr_list_name = '{}_{}_Gr'.format(self.crystal_system, time_info)
        gr_list_w_name = os.path.join(output_dir, gr_list_name)
        print('Saving {}'.format(gr_list_w_name))
        np.save(gr_list_w_name, gr_list)

        r_grid_name = '{}_{}_rgrid'.format(self.crystal_system, time_info)
        r_grid_w_name = os.path.join(output_dir, r_grid_name)
        np.save(r_grid_w_name, r)
        
        space_group_symbol_list_name = '{}_{}_SpaceGroupSymbol'.format(self.crystal_system, time_info)
        space_group_symbol_list_w_name= os.path.join(output_dir, space_group_symbol_list_name)
        np.save(space_group_symbol_list_w_name, space_group_symbol_list) #fmt="%s")
        
        el_list_name = '{}_{}_Element'.format(self.crystal_system, time_info)
        el_list_w_name = os.path.join(output_dir, el_list_name)
        np.save(el_list_w_name, el_list) #fmt="%s")
        
        print('''====SUMMARY====:
for {} cystsal sytem,
Number of cif pulled out and G(r) calculated is {}'''.format(self.crystal_system, np.shape(gr_list)))
        return gr_list
